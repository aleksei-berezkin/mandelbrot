export function mul2(aPtr: u32, bPtr: u32, cPtr: u32, _unused: u32): void {
    const aIsNeg = takeNegative(aPtr);
    const bIsNeg = aPtr === bPtr ? aIsNeg : takeNegative(bPtr);

    let curr: u64 = 0;
    let next: u64 = 0;
    for (let cIx: i32 = precision; cIx >= 0; cIx--) {
        //            0  1  2  3
        //            0  1  2  3
        //           03 13 23 33
        //        02 12 22 32
        //     01 11 21 31
        //  00 10 20 30
        //   0  1  2  3  4
        // precision = 4
        // 4: 13 22 31
        // 3: 03 12 21 30
        // 2: 02 11 20
        // 1: 01 10
        // 0: 00
        //
        //         1.1000_0000
        //        10.0100_0000

        for (let aIx: i32 = cIx === precision ? 1 : 0;
             aIx <= min(cIx, precision - 1);
             aIx++
        ) {
            const bIx = cIx - aIx;
            const a: u64 = load<u32>(aPtr + (aIx << 2));
            const b: u64 = load<u32>(bPtr + (bIx << 2));
            if (a !== 0 && b !== 0) {
                const m: u64 = a * b;
                curr += m;
                if (curr < m) {
                    next++;
                }
            }
        }

        //      0  1
        //      0  1
        //     01 11
        //  00 10
        //   0  1  2
        if (cIx < (precision as i32)) {
            store<u32>(cPtr + (cIx << 2), curr as u32);
        }
        // noinspection ShiftOutOfRangeJS
        curr = (curr >>> 32) | (next << 32);
        next = 0;
    }

    if (aIsNeg) setNegative(aPtr);
    if (bIsNeg && aPtr !== bPtr) setNegative(bPtr);
    if (aIsNeg !== bIsNeg) setNegative(cPtr);

}
